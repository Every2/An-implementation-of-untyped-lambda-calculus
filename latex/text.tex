\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
%\usepackage[latin1]{inputenc}
\usepackage{amsmath, amsfonts, amssymb, amsthm}  
\theoremstyle{definition}
\newtheorem{theorem}{Teorema}
\newtheorem{metatheorem}[theorem]{Metateorema}
\newtheorem{metadefinition}[theorem]{Metadefinição}
\newtheorem{definition}[theorem]{Definição}
\newtheorem{proposition}[theorem]{Proposição}
\newtheorem{lemma}[theorem]{Lema}
\newtheorem{corollary}[theorem]{Corolário}
\newtheorem{example}[theorem]{Exemplo}
\newtheorem{fact}[theorem]{Fato}

\sloppy
\DeclareMathOperator{\FV}{\mathrm{FV}}

\title{Uma Implementação do Cálculo Lambda não Tipado em Elixir}

\author{Christian S. Lima\inst{1}, Adolfo Neto\inst{1} }

\address{Universidade Tecnológica Federal do Paraná (UTFPR), Curitiba, Brasil \\
  \email{christiansantoslima21@gmail.com, adolfo@utfpr.edu.br}
}

\begin{document} 

\maketitle

\begin{abstract}

  
\end{abstract}
     
\begin{resumo} 
  Nesse artigo vamos fazer uma revisão bibliográfica sobre o cálculo lambda não tipado e apresentar uma implementação em Elixir.
\end{resumo}


\section{Introdução}

\section{Linguagem} \label{sec:firstpage}

\begin{definition}
  O alfabeto do cálculo lambda é dado pelos seguintes símbolos:
  \begin{itemize}
  \item um conjunto de variáveis:
    $$Var = \{x_i : i \in \mathbb{N}\};$$
  \item um abstrator: $\lambda$;
  \item três delimitadores: ``('', ``.'', ``)''.
  \end{itemize}
\end{definition}
\vspace{1cm}

\begin{definition}
  Os $\lambda$-termos são definidos de forma indutiva pelas regras:
  \begin{enumerate}
  \item todas as variáveis são $\lambda$-termos;
  \item se $M$ e $N$ são $\lambda$-termos, então $(MN)$ é um $\lambda$-termo (chamado de aplicação);
  \item Se $M$ é um $\lambda$-termo e $x$ uma variável, então $(\lambda x.M)$ é um $\lambda$-termo (chamado abstração). 
  \end{enumerate}
\end{definition}
\vspace{1cm}

\begin{definition}
  Definimos recursivamente o conjunto das variáveis que ocorrem livres em um $\lambda$-termo $M$ pelas regras:
  \begin{enumerate}
  \item $\FV[x] = \{x\}$;
  \item $\FV[NP] = \FV[N] \cup \FV[P]$;
  \item $\FV[\lambda x.N] = \FV[N] - \{x\}$.
  \end{enumerate}
\end{definition}
\vspace{1cm}

\begin{definition}
  Definimos recursivamente a substituição de todas as ocorrências livres de $x$ por $N$ pelas regras:
  \begin{enumerate}
  \item $x[x := N] = N$;
  \item $y[x := N] = y$, se $x \neq y$;
  \item $(PQ)[x := N] = P[x := N] Q[x := N]$;
  \item $(\lambda x.P)[x := N] = \lambda x.P$;
  \item $(\lambda y.P)[x := N] = \lambda y.P$ se $x \not\in \FV[P]$;
  \item $(\lambda y.P)[x := N] = \lambda y.P[x := N]$ se $x \in \FV[P]$ e $y \not\in \FV[N]$;
  \item $(\lambda y.P)[x := N] = \lambda z.P[y := z][x := N]$ se $x \in \FV[P]$ e $y \in \FV[N]$.  
  \end{enumerate}
\end{definition}
\vspace{1cm}

\begin{definition} \textbf{($\alpha$-conversão)}
  Seja um termo $P$ e que contém uma abstração $\lambda x.M$ como subtermo e seja $y \not\in \FV[M]$. Uma $\alpha$-conversão de $P$ é um termo $Q$ obtido a partir de $P$ substituindo uma ou mais ocorrências do subtermo $\lambda x.M$ por $\lambda y.M[x := y]$. 
\end{definition}

\section{$\beta$-redução}
\begin{definition}
  Seja um termo $P$ e que contém um subtermo da forma $(\lambda x.M)N$. Uma $\beta$-contração de $P$ é um termo $Q$ obtida a partir de $P$ substituindo uma ocorrência do subtermo $(\lambda x.M)N$ por $M[x := N]$. Denotamos essa relação por $P \to_{1 \beta}Q$.
\end{definition}
\vspace{1cm}

\begin{definition}
  Seja um termo $P$. Uma $\beta$-redução de $P$ é um termo $Q$ obtido a partir de $P$ por uma sequência da forma:
  $$P \equiv_\alpha P' \to_{1 \beta} P_1 \equiv_\alpha P_1' \to_{1 \beta} \ldots \to_{1 \beta} P_n \equiv_\alpha Q$$
\end{definition}

\section{Referências}

\nocite{*}
\bibliographystyle{sbc}
\bibliography{references}

\end{document}
